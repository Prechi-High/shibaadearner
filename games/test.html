<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Bubble Shooter Game</title>
<!-- Linking CSS & JS -->

    <style>
    /* Global/Body Styles */
    body{
     background-image: url('bg1.jpg');
     background-repeat:no-repeat;
     background-size:cover;
     background-attachment:fixed;
     color:#eee;
     margin:0;
     box-sizing: border-box;
}

/* Main Container/Canvas Positioning */
#main-container{
  height:1000px; /* Changed to 'px' for consistency */
  width:625px;   /* Changed to 'px' for consistency */
  box-sizing:border-box;
  margin: 20px auto 0 auto; /* Center the main game view */
  background: rgba(0,0,0,0.5); /* Semi-transparent background for the game area */
  border-radius: 10px;
  overflow: hidden; /* Keep game elements inside */
}

#viewport{
 height:625px; /* Canvas size */
 width:625px;
 border: none; /* Remove border */
 display: block;
}

/* --- HUD STYLING (The Game-Specific Look) --- */

.hud{
  display:flex;
  flex-direction: column; /* Stack stats and controls vertically */
  gap: 8px;
  padding: 10px 0; /* Padding top/bottom */
  width: 625px; /* Match main-container width */
  margin: 10px auto 0 auto; /* Center above the game */
  font-family: Arial, sans-serif;
}

.hud-stats-row {
  display: flex;
  justify-content: space-between; /* Spread stats out */
  padding: 0 5px;
  /* Use a gradient or a strong color to match game header feel */
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.1), rgba(0, 0, 0, 0.4));
  border-radius: 15px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
}

.stat{
  /* Reset the original .stat flex/background */
  background: none;
  padding: 8px 10px;
  border-radius: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column; /* Stack small text over big text */
  font-size: 14px;
  min-width: 100px;
  text-shadow: 1px 1px 2px #000;
  position: relative;
}

/* Decorative separator for stats */
.stat:not(:last-child)::after {
  content: '';
  position: absolute;
  right: 0;
  top: 15%;
  height: 70%;
  width: 1px;
  background: rgba(255, 255, 255, 0.2);
}


.stat small{
  color: #a0f0ff; /* Brighter small text color */
  font-size: 10px;
  text-transform: uppercase;
  font-weight: 700;
  margin-bottom: 2px;
}
.big{
  font-weight: 900;
  font-size: 18px;
  color: #ffffff;
}

/* Special color for the target/earned stat to draw attention */
.target .big, .earned .big {
  color: #ffde00;
}

/* Second Row: Controls and Extensions */
.hud-controls-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  padding: 5px 10px;
  /* Match the visual style of the stats row */
  background: rgba(0, 0, 0, 0.4); 
  border-radius: 10px;
}

.hud-buttons-group {
  display: flex;
  gap: 8px;
}

.extensions-stat {
  font-size: 12px;
  color: #9aa;
  padding: 5px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 5px;
  display: flex;
  align-items: center;
}

/* General Button Styling */
button {
  padding: 8px 15px;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
  box-shadow: 0 3px #333;
  transition: all 0.1s ease;
}

button:active {
  transform: translateY(1px);
  box-shadow: 0 1px #333;
}

#claimBtn {
  background: linear-gradient(180deg, #4CAF50, #2E8B57); /* Green/Claim */
  color: white;
}

#tryAgainBtn.secondary {
  background: linear-gradient(180deg, #FFD700, #DAA520); /* Gold/Try Again */
  color: #333;
}


/* --- Overlay and Popup Styles (improved) --- */
.overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.6); /* semi-transparent dark backdrop */
  padding: 40px; /* smaller padding */
  z-index: 999999; /* above canvas */
  backdrop-filter: blur(3px);
}

.popup {
  background: #121212; /* dark popup background */
  padding: 20px 24px;
  color: #fff;
  text-align: center;
  width: 100%;
  max-width: 520px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
  animation: popupFade 0.18s ease-out;
  border-radius: 12px;
}

@keyframes popupFade {
  from { transform: scale(0.985); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

.ad-progress {
  width: 100%;
  height: 12px;
  background: rgba(255,255,255,0.08);
  border-radius: 8px;
  margin-top: 12px;
  overflow: hidden;
}

.ad-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #63b3ed, #4299e1);
  transition: width 0.12s linear;
}

.muted { color: #8b98a6; }
.center { text-align: center; }
</style>
</head>

<body>
<div class="hud" aria-live="polite">
  <div class="hud-stats-row">
    <div class="stat time">
      <small>‚è∞ Time left</small>
      <div id="timeDisplay" class="big">02:00</div>
    </div>
    <div class="stat target">
      <small>üéØ Target</small>
      <div id="targetDisplay" class="big">$0.30 USDT</div>
    </div>
    <div class="stat earned">
      <small>üí∞ Earned</small>
      <div id="earnedDisplay" class="big">$0.0000 USDT</div>
    </div>
    <div class="stat balance">
      <small>üè¶ Balance</small>
      <div id="balanceDisplay" class="big">$1.20 USDT</div>
    </div>
  </div>

  <div class="hud-controls-row">
    <div class="extensions-stat">
      Extensions used this round: <span id="extensionsUsed">0</span> / 2
    </div>
    <div class="hud-buttons-group">
      <button id="tryAgainBtn" class="secondary">üîÅ Try Again</button>
     <!-- <button id="claimBtn">‚úÖ Claim Prize</button>  -->
    </div>
  </div>
</div> <!-- HUD: add this near your game canvas -->

<!-- End HUD -->
    <!-- main div  -->
<div id="main-container">
<canvas  id="viewport" width="625" height="625"></canvas></div>
    
    <script>
window.onload = function() {
    // Get the canvas and context
    var canvas = document.getElementById("viewport");
    var context = canvas.getContext("2d");
    
    // Timing/second
    var lastframe = 0;
    var fpstime = 0;
    var framecount = 0;
    var fps = 0;
    
    var initialized = false;
	// === Game economy variables ===
// === Game economy variables ===
let earned = 0.0;
let totalBalance = 0.0;  // default 0.00 USDT
let target = 0.30;
let timeLeft = 120; // seconds = 2 minutes
let extensionsUsed = 0;
let timerInterval = null;
let timerRunning = false;
	
    // Level
    var level = {
        x: 4,          
        y: 83,        
        width: 0,      
        height: 0,     
        columns: 15,   
        rows: 14,      
        tilewidth: 40,  
        tileheight: 40, 
        rowheight: 34,  
        radius: 20,    
        tiles: []    
    };

    // Define a tile class
    var Tile = function(x, y, type, shift) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.removed = false;
        this.shift = shift;
        this.velocity = 0;
        this.alpha = 1;
        this.processed = false;
    };
    
    // Player
    var player = {
        x: 0,
        y: 0,
        angle: 0,
        tiletype: 0,
        bubble: {
                    x: 0,
                    y: 0,
                    angle: 0,
                    speed: 1000,
                    dropspeed: 900,
                    tiletype: 0,
                    visible: false
                },
        nextbubble: {
                        x: 0,
                        y: 0,
                        tiletype: 0
                    }
    };
    
    // Neighbor offset table
    var neighborsoffsets = [[[1, 0], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1]], // Even row tiles
                            [[1, 0], [1, 1], [0, 1], [-1, 0], [0, -1], [1, -1]]];  // Odd row tiles
    
    // Number of different colors
    var bubblecolors = 7;
    
    // Game states
    var gamestates = { init: 0, ready: 1, shootbubble: 2, removecluster: 3, gameover: 4 };
    var gamestate = gamestates.init;
    
    // Score
    var score = 0;
    
    var turncounter = 0;
    var rowoffset = 0;
    
    // Animation variables
    var animationstate = 0;
    var animationtime = 0;
    
    // Clusters
    var showcluster = false;
    var cluster = [];
    var floatingclusters = [];
    
    // Images
    var images = [];
    var bubbleimage;
    
    // Image loading global variables
    var loadcount = 0;
    var loadtotal = 0;
    var preloaded = false;
    
    // Load images
    function loadImages(imagefiles) {
        // Initialize variables
        loadcount = 0;
        loadtotal = imagefiles.length;
        preloaded = false;
        
        // Load the images
        var loadedimages = [];
        for (var i=0; i<imagefiles.length; i++) {
            // Create the image object
            var image = new Image();
            
            // Add onload event handler
            image.onload = function () {
                loadcount++;
                if (loadcount == loadtotal) {
                    // Done loading
                    preloaded = true;
                }
            };
            
            // Set the source url of the image
            image.src = imagefiles[i];
            
            // Save to the image array
            loadedimages[i] = image;
        }
        
        // Return an array of images
        return loadedimages;
    }
    
    // Initialize the game
    function init() {
        // Load images
        images = loadImages(["bubble-sprites.png"]);
        bubbleimage = images[0];
    
        // Add mouse events
        canvas.addEventListener("mousemove", onMouseMove);
        canvas.addEventListener("mousedown", onMouseDown);
		document.getElementById("tryAgainBtn").onclick = () => newGame();
//document.getElementById("claimBtn").onclick = () => handleWin();
        
        // Initialize the two-dimensional tile array
        for (var i=0; i<level.columns; i++) {
            level.tiles[i] = [];
            for (var j=0; j<level.rows; j++) {
                // Define a tile type and a shift parameter for animation
                level.tiles[i][j] = new Tile(i, j, 0, 0);
            }
        }
        
        level.width = level.columns * level.tilewidth + level.tilewidth/2;
        level.height = (level.rows-1) * level.rowheight + level.tileheight;
        
        // Init the player
        player.x = level.x + level.width/2 - level.tilewidth/2;
        player.y = level.y + level.height;
        player.angle = 90;
        player.tiletype = 0;
        
        player.nextbubble.x = player.x - 2 * level.tilewidth;
        player.nextbubble.y = player.y;
        
        // New game
        newGame();
        
        // Enter main loop
        main(0);
    }
    function updateHUD() {
  // Earned shown with 4 decimal places as requested
  document.getElementById("earnedDisplay").innerText = `$${earned.toFixed(4)} USDT`;
  // Keep balance & target formatting as before (2 decimals)
  document.getElementById("balanceDisplay").innerText = `$${totalBalance.toFixed(2)} USDT`;
  document.getElementById("targetDisplay").innerText = `$${target.toFixed(2)} USDT`;
  document.getElementById("extensionsUsed").innerText = extensionsUsed;
	updateTimeDisplay();
}
function startTimer(resume = false) {
  clearInterval(timerInterval);
  timerRunning = true;
  if (!resume) timeLeft = 120; // only reset for new games
  updateHUD(); // sync UI

  timerInterval = setInterval(() => {
    if (!timerRunning) return;

    if (timeLeft <= 0) {
      timeLeft = 0; // clamp
      updateTimeDisplay();
      clearInterval(timerInterval);
      timerRunning = false;
      console.log("‚è∞ Timer hit zero ‚Äì calling handleTimeUp()");
      handleTimeUp();
      return;
    }

    timeLeft--;
    updateTimeDisplay();
  }, 1000);
}

function updateTimeDisplay() {
  let mins = Math.floor(timeLeft / 60);
  let secs = timeLeft % 60;
  document.getElementById("timeDisplay").innerText =
    `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

function handleTimeUp() {
  console.log("handleTimeUp() triggered. earned:", earned, "target:", target);
  if (earned >= target) {
    handleWin();
    return;
  }

  if (extensionsUsed < 2) {
    console.log("Calling showAdPopup()");
    showAdPopup();
  } else {
    console.log("Calling showLossPopup()");
    showLossPopup();
  }
}
	// ---- Paste this as top-level functions (not inside any other function) ----

function handleWin() {
  clearInterval(timerInterval);
  timerRunning = false;
  totalBalance += earned;
  updateHUD();
  // You can replace alert with a modal if you want
  alert(`üéâ You won! $${earned.toFixed(4)} added to your balance.`);
  // reset for next round
  earned = 0;
  target = 0.30;
  extensionsUsed = 0;
  updateHUD();
  newGame();
}

function showAdPopup() {
  console.log("showAdPopup() called"); // debug

  // Remove existing popup if any
  document.querySelectorAll(".overlay.ad-popup, .overlay.ad-progress").forEach(e => e.remove());

  const overlay = document.createElement("div");
  overlay.className = "overlay ad-popup";

  overlay.innerHTML = `
    <div class="popup center" role="dialog" aria-modal="true" aria-label="Watch ads to continue">
      <h3>‚è≥ Time‚Äôs Up!</h3>
      <p class="muted">Watch 3 simulated ads to get +1 minute and increase the target by $0.10.</p>
      <div style="margin-top:14px; display:flex; gap:10px; justify-content:center;">
        <button id="watchAdsBtn">‚ñ∂Ô∏è Watch Ads</button>
        <button id="quitGameBtn">‚ùå Quit</button>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);

  document.getElementById("watchAdsBtn").onclick = () => {
    overlay.remove();
    startAdProgress();
  };

  document.getElementById("quitGameBtn").onclick = () => {
    overlay.remove();
    showLossPopup();
  };
}

function startAdProgress() {
  // Remove any previous ad overlays
  document.querySelectorAll(".overlay.ad-progress").forEach(e => e.remove());

  const overlay = document.createElement("div");
  overlay.className = "overlay ad-progress";

  overlay.innerHTML = `
    <div class="popup center" role="dialog" aria-modal="true" aria-label="Watching ads">
      <h3>üì∫ Watching Ads</h3>
      <div id="adStatus" class="muted" style="margin-top:6px;">Ad 1 of 3 ‚Äî 0%</div>
      <div class="ad-progress" aria-hidden="true">
        <div class="ad-fill" id="adFill" style="width:0%"></div>
      </div>
      <div style="margin-top:12px; display:flex; gap:10px; justify-content:center;">
        <button id="cancelAdsBtn">‚úñÔ∏è Cancel</button>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);

  let adCount = 1;
  let progress = 0;
  const adFill = document.getElementById("adFill");
  const adStatus = document.getElementById("adStatus");

  // keep reference so we can clear it from cancel handler
  let adTimer = setInterval(() => {
    // increase progress quicker for a snappier demo; adjust as you like
    progress += 4;
    if (progress > 100) progress = 100;
    adFill.style.width = progress + "%";
    adStatus.innerText = `Ad ${adCount} of 3 ‚Äî ${progress}%`;

    if (progress >= 100) {
      if (adCount < 3) {
        adCount++;
        progress = 0;
        adFill.style.width = '0%';
        adStatus.innerText = `Ad ${adCount} of 3 ‚Äî 0%`;
      } else {
        // Completed all ads
        clearInterval(adTimer);
        overlay.remove();

        extensionsUsed++;
        timeLeft = 60; // +1 minute
        target += 0.10;
        updateHUD();
        // start fresh with new time (not resume)
        startTimer(false);
      }
    }
  }, 100);

  // Cancel button ‚Äî stop ads and show loss popup (or you can return to game)
  document.getElementById("cancelAdsBtn").onclick = () => {
    clearInterval(adTimer);
    overlay.remove();
    // Optionally allow quitting/back to loss screen
    showLossPopup();
  };
}

function showContinuePopup() {
  // Pause timer already done by checkGameOver() before calling this
  const overlay = document.createElement("div");
  overlay.className = "overlay continue-popup";

  overlay.innerHTML = `
    <div class="popup center">
      <h3>‚ö†Ô∏è Game Over?</h3>
      <p class="muted">Watch 1 ad to continue or quit (you‚Äôll lose $${earned.toFixed(4)}).</p>
      <div style="margin-top:12px;display:flex;gap:10px;justify-content:center;">
        <button id="watchOneAdBtn">‚ñ∂Ô∏è Watch Ad</button>
        <button id="quitConfirmBtn">‚ùå Quit</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);

  // Watch 1 ad flow ‚Äî preserve remaining time and HUD
  document.getElementById("watchOneAdBtn").onclick = () => {
    overlay.remove();
    const previousTime = timeLeft;
    startSingleAd(() => {
      resetBoardForContinue();
      timeLeft = previousTime;
      updateHUD();
      startTimer(true);
    });
  };

  // Quit flow ‚Äî confirm losing earnings
  document.getElementById("quitConfirmBtn").onclick = () => {
    const confirmQuit = confirm(`If you quit now, you'll lose $${earned.toFixed(4)}. Are you sure?`);
    if (confirmQuit) {
      overlay.remove();
      earned = 0;
      updateHUD();
      showLossPopup();
    }
  };
}

// Simple single ad progress (like the 3-ad version)
function startSingleAd(callback) {
  // Remove any previous ad overlays
  document.querySelectorAll(".overlay.ad-progress").forEach(e => e.remove());

  const overlay = document.createElement("div");
  overlay.className = "overlay ad-progress";
  overlay.style.display = "flex"; // make visible immediately

  overlay.innerHTML = `
    <div class="popup center">
      <h3>üì∫ Watching Ad...</h3>
      <p>Please wait while the ad finishes.</p>
      <div class="ad-progress">
        <div class="ad-fill" id="singleAdFill"></div>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);

  let progress = 0;
  const adFill = document.getElementById("singleAdFill");

  const timer = setInterval(() => {
    progress += 2;
    adFill.style.width = progress + "%";
    if (progress >= 100) {
      clearInterval(timer);
      overlay.remove();
      callback();
    }
  }, 100);
}
function showLossPopup() {
  // Remove any existing loss overlay
  const old = document.querySelector(".overlay.loss-popup");
  if (old) old.remove();

  const overlay = document.createElement("div");
  overlay.className = "overlay loss-popup";
  overlay.style.display = "flex";

  overlay.innerHTML = `
    <div class="popup center">
      <h3>üò¢ You Lost</h3>
      <p>You didn‚Äôt reach your target. Your earnings have been reset.</p>
      <div style="margin-top:12px; display:flex; gap:8px; justify-content:center;">
        <button id="playAgainBtn">üîÅ Play Again</button>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);

  document.getElementById("playAgainBtn").onclick = () => {
    overlay.remove();
    earned = 0;
    target = 0.30;
    extensionsUsed = 0;
    updateHUD();
    newGame();
  };
}

function quitGame() {
  clearInterval(timerInterval);
  timerRunning = false;
  // remove any popups
  const ad = document.querySelector(".overlay.ad-popup");
  if (ad) ad.remove();
  const loss = document.querySelector(".overlay.loss-popup");
  if (loss) loss.remove();

  alert("üëã Game exited. Thanks for playing!");
}
	//main loop
	function main(tframe) {
        // Request animation frames
        window.requestAnimationFrame(main);
    
        if (!initialized) {
            // Preloader
            
            // Clear the canvas
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the frame
            drawFrame();
            
            // Draw a progress bar
            var loadpercentage = loadcount/loadtotal;
            context.strokeStyle = "#ff8080";
            context.lineWidth=3;
            context.strokeRect(18.5, 0.5 + canvas.height - 51, canvas.width-37, 32);
            context.fillStyle = "#ff8080";
            context.fillRect(18.5, 0.5 + canvas.height - 51, loadpercentage*(canvas.width-37), 32);
            
            // Draw the progress text
            var loadtext = "Loaded " + loadcount + "/" + loadtotal + " images";
            context.fillStyle = "#000000";
            context.font = "16px Verdana";
            context.fillText(loadtext, 18, 0.5 + canvas.height - 63);
            
            if (preloaded) {
                // Add a delay for demonstration purposes
                setTimeout(function(){initialized = true;}, 1000);
            }
        } else {
            // Update and render the game
            update(tframe);
            render();
        }
    }
    
    // Update the game state
    function update(tframe) {
        var dt = (tframe - lastframe) / 1000;
        lastframe = tframe;
        
        // Update the fps counter
        updateFps(dt);
        
        if (gamestate == gamestates.ready) {
            // Game is ready for player input
        } else if (gamestate == gamestates.shootbubble) {
            // Bubble is moving
            stateShootBubble(dt);
        } else if (gamestate == gamestates.removecluster) {
            // Remove cluster and drop tiles
            stateRemoveCluster(dt);
        }
    }
    
    function setGameState(newgamestate) {
        gamestate = newgamestate;
        
        animationstate = 0;
        animationtime = 0;
    }
    
    function stateShootBubble(dt) {
        // Bubble is moving
        
        // Move the bubble in the direction of the mouse
        player.bubble.x += dt * player.bubble.speed * Math.cos(degToRad(player.bubble.angle));
        player.bubble.y += dt * player.bubble.speed * -1*Math.sin(degToRad(player.bubble.angle));
        
        // Handle left and right collisions with the level
        if (player.bubble.x <= level.x) {
            // Left edge
            player.bubble.angle = 180 - player.bubble.angle;
            player.bubble.x = level.x;
        } else if (player.bubble.x + level.tilewidth >= level.x + level.width) {
            // Right edge
            player.bubble.angle = 180 - player.bubble.angle;
            player.bubble.x = level.x + level.width - level.tilewidth;
        }
 
        // Collisions with the top of the level
        if (player.bubble.y <= level.y) {
            // Top collision
            player.bubble.y = level.y;
            snapBubble();
            return;
        }
        
        // Collisions with other tiles
        for (var i=0; i<level.columns; i++) {
            for (var j=0; j<level.rows; j++) {
                var tile = level.tiles[i][j];
                
                // Skip empty tiles
                if (tile.type < 0) {
                    continue;
                }
                
                // Check for intersections
                var coord = getTileCoordinate(i, j);
                if (circleIntersection(player.bubble.x + level.tilewidth/2,
                                       player.bubble.y + level.tileheight/2,
                                       level.radius,
                                       coord.tilex + level.tilewidth/2,
                                       coord.tiley + level.tileheight/2,
                                       level.radius)) {
                    
                    // Intersection with a level bubble
                    snapBubble();
                    return;
                }
            }
        }
    }
    
    function stateRemoveCluster(dt) {
  if (animationstate == 0) {
    resetRemoved();

    // ‚úÖ reward once per valid cluster
    if (cluster && cluster.length >= 3) {
      earned += 0.0025;
      updateHUD();
      if (earned >= target) handleWin();
    }

    floatingclusters = findFloatingClusters();
    
            if (floatingclusters.length > 0) {
                // Setup drop animation
                for (var i=0; i<floatingclusters.length; i++) {
                    for (var j=0; j<floatingclusters[i].length; j++) {
                        var tile = floatingclusters[i][j];
                        tile.shift = 0;
                        tile.shift = 1;
                        tile.velocity = player.bubble.dropspeed;
                        
                       // Add cluster score
score += cluster.length * 100;
                     // === Add USDT reward for each cluster ===
//earned += 0.01;
updateHUD();
if (earned >= target) {
  handleWin();
}
                    }
                }
            }
            
            animationstate = 1;
        }
        
        if (animationstate == 1) {
            // Pop bubbles
            var tilesleft = false;
            for (var i=0; i<cluster.length; i++) {
                var tile = cluster[i];
                
                if (tile.type >= 0) {
                    tilesleft = true;
                    
                    // Alpha animation
                    tile.alpha -= dt * 15;
                    if (tile.alpha < 0) {
                        tile.alpha = 0;
                    }

                    if (tile.alpha == 0) {
                        tile.type = -1;
                        tile.alpha = 1;
                    }
                }                
            }
            
            // Drop bubbles
            for (var i=0; i<floatingclusters.length; i++) {
                for (var j=0; j<floatingclusters[i].length; j++) {
                    var tile = floatingclusters[i][j];
                    
                    if (tile.type >= 0) {
                        tilesleft = true;
                        
                        // Accelerate dropped tiles
                        tile.velocity += dt * 700;
                        tile.shift += dt * tile.velocity;
                            
                        // Alpha animation
                        tile.alpha -= dt * 8;
                        if (tile.alpha < 0) {
                            tile.alpha = 0;
                        }

                        // Check if the bubbles are past the bottom of the level
                        if (tile.alpha == 0 || (tile.y * level.rowheight + tile.shift > (level.rows - 1) * level.rowheight + level.tileheight)) {
                            tile.type = -1;
                            tile.shift = 0;
                            tile.alpha = 1;
                        }
                    }

                }
            }
            
            if (!tilesleft) {
                // Next bubble
                nextBubble();
                
                // Check for game over
                var tilefound = false
                for (var i=0; i<level.columns; i++) {
                    for (var j=0; j<level.rows; j++) {
                        if (level.tiles[i][j].type != -1) {
                            tilefound = true;
                            break;
                        }
                    }
                }
                
                if (tilefound) {
                    setGameState(gamestates.ready);
                } else {
                    // No tiles left, game over
                    setGameState(gamestates.gameover);
                }
            }
        }
    }
    
    // Snap bubble to the grid
    function snapBubble() {
        // Get the grid position
        var centerx = player.bubble.x + level.tilewidth/2;
        var centery = player.bubble.y + level.tileheight/2;
        var gridpos = getGridPosition(centerx, centery);

        // Make sure the grid position is valid
        if (gridpos.x < 0) {
            gridpos.x = 0;
        }
            
        if (gridpos.x >= level.columns) {
            gridpos.x = level.columns - 1;
        }

        if (gridpos.y < 0) {
            gridpos.y = 0;
        }
            
        if (gridpos.y >= level.rows) {
            gridpos.y = level.rows - 1;
        }

        // Check if the tile is empty
        var addtile = false;
        if (level.tiles[gridpos.x][gridpos.y].type != -1) {
            // Tile is not empty, shift the new tile downwards
            for (var newrow=gridpos.y+1; newrow<level.rows; newrow++) {
                if (level.tiles[gridpos.x][newrow].type == -1) {
                    gridpos.y = newrow;
                    addtile = true;
                    break;
                }
            }
        } else {
            addtile = true;
        }

        // Add the tile to the grid
        if (addtile) {
            // Hide the player bubble
            player.bubble.visible = false;
        
            // Set the tile
            level.tiles[gridpos.x][gridpos.y].type = player.bubble.tiletype;
            
            // Check for game over
            if (checkGameOver()) {
                return;
            }
            
            // Find clusters
            cluster = findCluster(gridpos.x, gridpos.y, true, true, false);
            
            if (cluster.length >= 3) {
                // Remove the cluster
                setGameState(gamestates.removecluster);
                return;
            }
        }
        
        // No clusters found
        turncounter++;
        if (turncounter >= 5) {
            // Add a row of bubbles
            addBubbles();
[...]}