<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Bridge Run — Prototype</title>
<style>
  :root{--bg:#86c2ff;--ground:#2e8546;--bridge:#7b5230}
  html,body{height:100%;margin:0;background:var(--bg);-webkit-tap-highlight-color:transparent}
  canvas{display:block;background:linear-gradient(#86c2ff,#cceeff);width:100%;height:100vh}
  #ui{position:fixed;left:8px;top:8px;z-index:10;font-family:system-ui,Segoe UI,Roboto,Arial;color:#032}
  #score{font-size:18px;background:rgba(255,255,255,0.85);padding:6px 10px;border-radius:8px}
  #buttons{position:fixed;right:8px;top:8px;z-index:10}
  button{font-size:14px;padding:6px 10px;margin-left:6px;border-radius:8px}
  #hint{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);background:rgba(255,255,255,0.9);padding:8px 12px;border-radius:999px;font-size:14px}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui"><div id="score">Score: 0</div></div>
<div id="buttons"><button id="pauseBtn">Pause</button><button id="restartBtn">Restart</button></div>
<div id="hint">Tap anywhere to jump • Hold to charge jump</div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize);
  resize();// Game state const state = { running: true, score: 0, phase: 'bridge', // 'bridge' then 'main' speed: 160, // px/sec world speed lastTime: 0, player: null, entities: [], cameraX: 0, bridgeEndX: 1200 };

// Player function createPlayer(){ return { x: 120, y: canvas.height/2, w: 36, h: 36, vx: 0, vy: 0, onGround: false, jumpPower: 420, charge:0, color:'#ffcc00', dead:false }; } state.player = createPlayer();

// Utilities function rand(min,max){return Math.random()*(max-min)+min}

// Level: bridge section (a wooden bridge across a chasm) function drawBridge(ctx, cam){ const bridgeY = canvas.height*0.62; // left ground ctx.fillStyle = '#553'; ctx.fillRect(-100-cam, bridgeY+40, 500, canvas.height - bridgeY - 40);

// bridge planks
ctx.fillStyle = '#7b5230';
const startX = -cam + 200;
const plankW = 80;
for(let x = startX; x < state.bridgeEndX - cam; x += plankW){
  ctx.fillRect(x, bridgeY, plankW-6, 22);
  // rope supports
  ctx.beginPath(); ctx.moveTo(x+10, bridgeY); ctx.lineTo(x+10, bridgeY-30); ctx.strokeStyle='#6b3'; ctx.lineWidth=2; ctx.stroke();
}
// right land (bridge end)
ctx.fillStyle = '#553';
ctx.fillRect(state.bridgeEndX - cam + 40, bridgeY+40, 1000, canvas.height - bridgeY - 40);

}

// Create obstacles - some logs/crates on bridge and moving enemies after bridge function spawnInitialObstacles(){ state.entities = []; // place some obstacle boxes on the bridge for(let i=1;i<=6;i++){ const x = 300 + i120 + rand(-20,20); const isGap = Math.random() < 0.15; state.entities.push({type: isGap? 'gap':'crate', x, w: isGap? 60:40, y:0, passed:false}); } // place an enemy shortly after bridge for(let i=0;i<8;i++){ const x = state.bridgeEndX + 200 + i220 + rand(-30,30); state.entities.push({type:'enemy', x, w:36, y:0, dir: Math.random()>0.5?1:-1, t:rand(0,1)}); } } spawnInitialObstacles();

// Input: touch/click to jump let pointerDown = false; let pointerTime = 0; function pointerStart(e){ e.preventDefault(); pointerDown = true; pointerTime = performance.now(); } function pointerEnd(e){ e.preventDefault(); pointerDown = false; const dt = (performance.now()-pointerTime)/1000; // short tap or long if(!state.player.dead){ const charge = Math.min(1, Math.max(0.12, dt)); state.player.vy = -state.player.jumpPower*(0.9 + charge*0.9); state.player.onGround = false; } } canvas.addEventListener('touchstart', pointerStart, {passive:false}); canvas.addEventListener('mousedown', pointerStart); canvas.addEventListener('touchend', pointerEnd); canvas.addEventListener('mouseup', pointerEnd);

// Buttons document.getElementById('pauseBtn').addEventListener('click', ()=>{ state.running = !state.running; document.getElementById('pauseBtn').textContent = state.running? 'Pause' : 'Resume';}); document.getElementById('restartBtn').addEventListener('click', ()=>{ restart(); });

function restart(){ state.player = createPlayer(); state.score = 0; state.running = true; state.phase='bridge'; state.cameraX = 0; state.bridgeEndX = 1200; spawnInitialObstacles(); }

// Physics & update function update(dt){ if(!state.running) return; const p = state.player; // forward auto-scroll state.cameraX += state.speed * dt; state.score += Math.floor(state.speed * dt * 0.02);

// apply gravity
p.vy += 1400 * dt;
p.y += p.vy * dt;

// simple ground on bridge or main ground
const groundY = canvas.height*0.62 - (state.phase==='bridge' ? 0 : 30);
if(p.y + p.h/2 >= groundY){ p.y = groundY - p.h/2; p.vy = 0; p.onGround = true; }

// move player forward slowly relative to camera
// collisions with crates
for(const e of state.entities){
  const ex = e.x - state.cameraX;
  if(e.type==='crate'){
    const ew = e.w; const ey = groundY - (ew/2);
    if(!e.passed && p.x + p.w/2 > ex && p.x - p.w/2 < ex+ew){
      // simple collision from above
      if(p.y + p.h/2 > ey - 2){ // landing on crate
        p.y = ey - p.h/2; p.vy = 0; p.onGround = true; e.passed = true; state.score += 4;
      }
    }
  }
  if(e.type==='gap'){
    // if player above gap while on bridge and falls
    const gapX = ex; const gapW = e.w;
    if(p.x > gapX && p.x < gapX + gapW && p.y + p.h/2 >= groundY - 1){
      // fall into gap
      p.vy = 800; p.onGround = false; p.y += 4;
    }
  }
  if(e.type==='enemy'){
    // enemy moves left/right around its original x
    e.t += dt;
    const wiggle = Math.sin(e.t*2)*20;
    const enemyX = e.x + wiggle - state.cameraX;
    const distX = Math.abs(enemyX - p.x);
    if(distX < (e.w + p.w)/2 && Math.abs((canvas.height*0.62) - p.y) < 80){
      // dead!
      p.dead = true; state.running = false;
    }
  }
}

// Transition to main when camera passes bridgeEndX
if(state.cameraX > state.bridgeEndX - 200 && state.phase==='bridge'){
  state.phase = 'main';
  // change visual behavior: raise ground and spawn more enemies
  state.speed += 30; // faster
}

// If player falls below screen
if(p.y - p.h/2 > canvas.height + 50){ p.dead = true; state.running = false; }

}

// Draw function draw(){ // clear ctx.clearRect(0,0,canvas.width,canvas.height); // sky gradient background const g = ctx.createLinearGradient(0,0,0,canvas.height); g.addColorStop(0,'#86c2ff'); g.addColorStop(1,'#cfeefd'); ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

const cam = state.cameraX;

// draw bridge or main environment
if(state.phase === 'bridge'){
  drawBridge(ctx, cam);
} else {
  // main world: rolling hills
  const groundY = canvas.height*0.62 - 30;
  ctx.fillStyle='#3a7';
  for(let i=-1;i<6;i++){
    const hx = (i*400 - (cam*0.4 % 400));
    ctx.beginPath(); ctx.ellipse(hx+220, groundY+40, 200, 50, 0, 0, Math.PI*2); ctx.fill();
  }
}

// draw entities
for(const e of state.entities){
  const ex = e.x - cam;
  if(ex < -200 || ex > canvas.width + 200) continue;
  if(e.type==='crate'){
    ctx.fillStyle='#6b3'; ctx.fillRect(ex, canvas.height*0.62 - 40, e.w, 40);
  } else if(e.type==='gap'){
    // nothing visible
  } else if(e.type==='enemy'){
    const wig = Math.sin(e.t*2)*20;
    const ex2 = e.x + wig - cam;
    ctx.fillStyle='#d33'; ctx.beginPath(); ctx.arc(ex2, canvas.height*0.62 - 20, 18,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#700'; ctx.fillRect(ex2-12, canvas.height*0.62 - 10, 24, 8);
  }
}

// draw player
const p = state.player;
ctx.save(); ctx.translate(p.x, p.y);
ctx.fillStyle = p.dead? '#555' : p.color;
ctx.beginPath(); ctx.arc(0,0, p.w/2, 0, Math.PI*2); ctx.fill();
ctx.restore();

// HUD
document.getElementById('score').textContent = 'Score: ' + state.score;

if(!state.running){
  ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = 'white'; ctx.font = 'bold 28px system-ui'; ctx.textAlign='center';
  if(state.player.dead) ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 10);
  else ctx.fillText('Paused', canvas.width/2, canvas.height/2 - 10);
  ctx.font = '16px system-ui'; ctx.fillText('Tap Restart to play again', canvas.width/2, canvas.height/2 + 24);
}

}

// Main loop function loop(ts){ if(!state.lastTime) state.lastTime = ts; const dt = Math.min(1/30, (ts - state.lastTime)/1000); state.lastTime = ts; update(dt); draw(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

// Small demo polish: allow horizontal movement via tilt/keyboard for debugging addEventListener('keydown', e=>{ if(e.key === ' '){ if(state.player.onGround){ state.player.vy = -420; state.player.onGround=false }} if(e.key==='r') restart(); });

})(); </script>

</body>
</html>
